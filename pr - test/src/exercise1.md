> Принцип работы балансировщика нагрузки (Load Balancer, LB) - он находится между сервером/серверами сайтов/приложений и пользователям, получая запрос, определяет, какой сервер в пуле доступен, а затем направляет запрос на него. Перенаправляя запросы на доступный сервер/сервера с более низкой рабочей нагрузкой, снижается загруженность и обеспечивается высокая доступность и надежность. Гибкость обеспечивается динамически добавлением/отключением серверов в случае высокого или низкого спроса. Также LB обеспечивает аварийное переключение в дополнение к повышению производительности, перенаправляя рабочую нагрузку с отказавшего сервера на резервный, уменьшая воздействие на конечных пользователей.

Существует много различных **алгоритмов балансировки нагрузки** (Load Balancing Algorithm). Выбирая используемый метод, нужно исходить из: специфики конкретного проекта и целей, которые планируется достичь.
**Алгоритм балансировки**, в идеале, должен обладать следующими свойствами: 
- **справедливость** : каждый запрос обрабатывается - на каждый выделяются системные ресурсы (нет ожидания очереди из запросов с высокой нагрузкой на сервер);
- **эффективность** : серверы из пула должны всегда работать и на полную мощность (главная задача алгоритма: распределить нагрузку максимально равномерно, нет простоя);
- **скорость - сокращение времени выполнения запроса и отклика** : обеспечивается быстрая обработка запросов; минимальное время между началом постановки запроса в очередь на обработку и до его завершения; минимизация времени получения ответа пользователем;
- **предсказуемость** : показывает эффективность в решении задач при конкретной нагрузке и смоделированных ситуациях; 
- **масштабирумость** : алгоритм сохраняет работоспособность при увеличении нагрузки.

# Алгоритмы балансировки нагрузки (особенности и недостатки)

## ★  RR - **Round Robin** (циклический, круговой, карусельный)
- алгоритм кругового обслуживания и распределения нагрузки, балансировщик держит очередь из серверов и последовательно делает перебор по круговому циклу распределяя запросы: первый передаётся одному серверу, затем следующий -  другому и так до достижения последнего сервера, а затем всё начинается сначала. Т.е. сервера по очереди обрабатывает запрос и после помещаются в её конец, работая по замкнутому кругу. 

![RR](materials/1.png)

**Плюсы:**
```
+ самый простой, удобный по затратам и эффективности механизм балансировки
+ независимость от протокола высокого уровня : для работы используется любой протокол, в котором обращение к серверу идёт по имени; 
+ не зависит от нагрузки на сервер: кэширующие серверы помогут справиться с любым наплывом клиентов; 
+ подходит, когда сервера в пуле имеют одинаковую мощность и время обработки запросов; 
+ не требует связи между серверами (подходит для локальной и глобальной балансировки); 
+ низкая стоимость: для работы достаточно добавить несколько записей в DNS (Domain Name System - "система доменных имён"); 
+ сервера равномерно нагружены.
```
**Минусы:**
```
- при выполнении операций у каждого сервера должен быть в наличии одинаковый набор ресурсов; 
- не учитывает загруженность сервера в составе кластера (один - 100%, другой -20%); 
- перегруженный сервер всё равно будет получать запросы; 
- не учитывает уже имеющуюся нагрузку и колебания мощностей сервера; 
- сравнительно низкая эффективность без учета текущей нагрузки - дисбаланс; 
- ограниченность в сфере применения.
```
## ★ WRR - **Weighted Round Robin** (взвешенный циклический перебор)
-  усовершенствованная версия алгоритма Round Robin, суть которых заключается в следующем: каждому серверу присваивается определенный весовой коэффициент в соответствии с учётом его производительности и мощности. 

**Плюсы:**
```
+ при правильно подобранном весе - более эффективная работа, чем RR;  
+ учитывает производительность сервера : чем мощнее, тем больше обрабатывает;
+ сервера мощнее будут иметь больший вес -> обрабатывают больше запросов чем другие; 
+ более производительный сервер будет получать запросы чаще, хорошая эффективность; 
+ гибкое и равномерное распределение нагрузки.
```
**Минусы:**
```
- сложность ручной установки производительности сервера - приведение к одному числу; 
- проблема с отказоустойчивостью, под вопросом остаются колбания запросов; 
- состояние активного сервера не учитывается;  
- запросы могут отправляться к серверам, находящимся в состоянии простоя;   
- статистически не самая эффективная балансировка.
```

![WRR-DWRR](materials/2-3.png)

## ★ DWRR - **Dynamic Weighted Round Robin** ("динамический взвешенный циклический")
- усовершенствованная версия алгоритма Round Robin, которая способна адаптироваться к изменениям производительности сервера со временем: вычисляет вес динамически при помощи вспомогательной метрики: задержки, чем быстрее идёт обработка у сервера - тем больше ему передаётся запросов.

**Плюсы:**
```
+ адаптируется к изменениям производительности сервера со временем;  
+ хорошо учитывает колебания и мощности сервера, затраты на запросы;  
+ отсутствует необходимость заранее указывать вес каждого сервера, как в WR.  
```
**Минусы:**
```
- сложность процессинга; 
- состояние каждого сервера не учитывается; 
- не учитывается кол-во активных подключений. 
``` 

## ☆ LC (leastconn) - **Least Connections** (наименьшее количество соединений)
-  алгоритм, где каждый последующий запрос направляется на сервер с наименьшим количеством активных поддерживаемых подключений; учитываться не просто нагрузка на сервер, но и количество одновременных соединений с данным сервером в данный момент. Похоже на очередь с приоритетом, которая отсортирована по количеству активных пользователей, где первый сервер имеет наименьшее количество соединений и предполагает отправку нового запроса наименее загруженному серверу.

**Плюсы:**
```
+ учитывает кол-во подключений, поддерживаемых серверами в текущий момент времени;  
+ позволяет адекватно распределять нагрузку по серверам с приблизительно одинаковыми параметрами и работает чрезвычайно хорошо вне зависимости от степени колебаний серверов;
+ работает эффективно, когда в пуле серверов много неравномерно распределенных активных постоянных соединений (стриминг сервис, онлайн чат);  
+ избавляет от неопределённости, обеспечивая точное понимание того, чем занят каждый из серверов, обеспечивая использование всех доступных ресурсов;
+ простота в реализации и хорошая производительность. 
```
**Минусы:**
```
- не учитывает весовой коэффициент и время ответа; 
- сложность в настройке для обеспечения равномерного распределения нагрузки; 
- может потребовать дополнительное оборудование для поддержания высокого уровня обслуживания, иначе из-за превышения кол-ва запросов, ожидаемо снизиться производительность ответов; 
- нет иммунитета к отбрасыванию запросов (возможен при полном отсутствии места в очередях);
- при планировании и распределении нагрузки учитывается небольшое кол-во параметров. *есть усовершенствованные варианты 
```
> *усовершенствованные варианты Least Connections:
>  - *Weighted LC* : учитывает при распределении нагрузки не только кол-во активных подключений, но и весовой коэффициент серверов; используется в кластерах, состоящих из серверов с разными техническими характеристиками и разной производительностью.
>  - *Locality-Based LC Scheduling* : создан специально для кэширующих прокси-серверов : наибольшее кол-во запросов передаётся серверам с наименьшим кол-вом активных подключений. За каждым из клиентских серверов закрепляется группа клиентских IP. Запросы с этих IP направляются на «родной» сервер, если он не загружен полностью, иначе запрос будет перенаправлен на другой сервер, загруженный менее чем наполовину.
>  - *L-B LC Scheduling with Replication Scheduling* : каждый IP-адрес закрепляется за целой группой серверов. Запрос передаётся наименее загруженному серверу из группы, если все будут перегружены, то будет зарезервирован новый сервер, который добавляется к начальной группе, обслуживающей IP - с которого был отправлен запрос. После наиболее загруженный сервер будет удален из этой группы, чтобы избежать избыточной репликации.
>  - *Least Response Time* (наименьшее время отклика): учитывает не только кол-во соединений, но и среднее время отклика - распределяет запросы на сервер с наименьшим количеством активных подключений и с самым быстрым средним временем отклика на запрос мониторинга работоспособности. Первым в списке будет сервер с наименьшим количеством подключений и наименьшим временем ответа. Позволяет выровнять нагрузку если сервера отвечают с разной скоростью т.к. скорость отклика показывает, насколько загружен сервер.

![LC-PEWMA](materials/4-5.png)

## ★ PEWMA - **peak exponentially weighted moving average** (“пиковое экспоненциально взвешенное скользящее среднее”)
- алгоритм учитывающий задержки, в основном используется для их оптимизации. Для каждого сервера отслеживается задержка последних запросов, вместо среднего значения учитывается сумма, экспоненциально снижая коэффициент масштаба (чем старее задержка, тем меньше она влияет на сумму, а недавние запросы влияют на расчёт сильнее, чем старые). Значение умножается на кол-во открытых соединений с сервером, и в результате используется для выбора сервера, которому будет отправлен следующий запрос - чем меньше значение, тем лучше.

**Плюсы:**
```
+ скомбинированный алгоритм сочетающий принципы DWRR & LC:  
+ учёт задержки как в WWR (weighted round robin);  
+ надёжность как в LC (least connections);  
+ хорошая производительность и имеет много настраиваемых параметров.
```
**Минусы:**
```
- сосредоточен на одной цели : добиться наилучшей мин. задержки; 
- со временем алгоритм начинает вести себя хуже, чем LC;  
- иногда может обеспечивать неполную загрузку сервера; 
- дополнительная сложность при настройке параметров. 
 ```
## ☆ **Hash** ("хэш")
- алгоритм хеширования определяет рнаспределние запроса к серверу на основе назначенного ключа, такого как : **IP-адрес клиента**, **номер порта** или **URL-адрес запроса (значение заголовка HTTP)**. Один и тот же клиент обслуживается одним и тем же сервером. Используется для приложений, полагающихся на сохраненную информацию о пользователях, т.е. когда сервер хранит локальные данные, необходимые для ответа на запрос.

**Плюсы:**
```
+ сохраняется информация о действиях пользователях и посещениях сайта (например, корзина на сайте в интернет-магазине); 
+ удобный метод, если приложение требует хранение информации о состоянии на стороне сервера (например, файлы cookie);  
+ повышает безопасность в связи с аутентификацией пользователей и возможно продолжение сессии после дисконнекта. 
```
**Минусы:**
```
- нагрузка на сервер: запросы от одного и того же IP или по одному и тому же URL отправляют на один и тот же; 
- не может обеспечить равномерное распределение запросов;
- высокая и не сбалансированная нагрузка на сервер (хранение данных).  
```
> *вариации Hash:
> - *DHS - Destination Hash Scheduling - был создан для работы с кластером кэширующих прокси-серверов; сервер, обрабатывающий запрос, выбирается из статической таблицы по IP-адресу получателя.
> - *SHS - Source Hash Scheduling - основывается на тех же самых принципах, что DHS, только сервер, который будет обрабатывать запрос, выбирается из таблицы по IP-адресу отправителя.

![HASH-SS](materials/6-7.png)

## ☆ SS - **Sticky Sessions** (непрерывные “липкие” сессии)
- алгоритм распределения входящих запросов в зависимости от IP-адреса пользователя, при котором запросы передаются на один и тот же сервер группы. Обращение пользователя *закрепляет его за первым сервером*, что обслужил запрос, нет выборочно поиска в пуле, соответственно, все пакеты в рамках одной сессии будут отправляться только на этот конкретный сервер. 

**Плюсы:**
```
+ предоставляет приятный непрерывный пользовательский опыт;  
+ эффективно использует данные и память;   
+ быстро и легко настраивается;  
+ есть перенаправление запроса на другой сервер группы, если первый станет недоступен;
+ используется, если HTTP-заголовки не доступны.
```
**Минусы:**
```
- возникают проблемы с привязкой сессий, если клиент использует динамический IP; 
- несбалансированная нагрузка : большое кол-во запросов проходит через один прокси-сервер (решается использованием cookie); 
- высокая нагрузка на сервер (хранение кэша и сохраненных сессий); 
- сложное обслуживание серверов, и ограниченность в их кол-ве из-за группы подключения; 
- если первый сервер выходит из строя, то пользовательская информация теряется.
```
